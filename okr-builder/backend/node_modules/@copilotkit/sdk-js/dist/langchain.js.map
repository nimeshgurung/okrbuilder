{"version":3,"sources":["../src/langchain.ts","../src/langgraph.ts"],"sourcesContent":["console.warn(\n  \"Warning: '@copilotkit/sdk-js/langchain' is deprecated and will be removed in a future release. Please use '@copilotkit/sdk-js/langgraph' instead.\",\n);\n\nexport {\n  CopilotKitPropertiesAnnotation,\n  CopilotKitStateAnnotation,\n  type CopilotKitState,\n  type CopilotKitProperties,\n  copilotkitCustomizeConfig as copilotKitCustomizeConfig,\n  copilotkitExit as copilotKitExit,\n  copilotkitEmitState as copilotKitEmitState,\n  copilotkitEmitMessage as copilotKitEmitMessage,\n  copilotkitEmitToolCall as copilotKitEmitToolCall,\n  convertActionToDynamicStructuredTool,\n  convertActionsToDynamicStructuredTools,\n} from \"./langgraph\";\n","import { RunnableConfig } from \"@langchain/core/runnables\";\nimport { dispatchCustomEvent } from \"@langchain/core/callbacks/dispatch\";\nimport { convertJsonSchemaToZodSchema, randomId } from \"@copilotkit/shared\";\nimport { Annotation, MessagesAnnotation, interrupt } from \"@langchain/langgraph\";\nimport { DynamicStructuredTool } from \"@langchain/core/tools\";\nimport { AIMessage } from \"@langchain/core/messages\";\n\ninterface IntermediateStateConfig {\n  stateKey: string;\n  tool: string;\n  toolArgument?: string;\n}\n\ninterface OptionsConfig {\n  emitToolCalls?: boolean | string | string[];\n  emitMessages?: boolean;\n  emitAll?: boolean;\n  emitIntermediateState?: IntermediateStateConfig[];\n}\n\nexport const CopilotKitPropertiesAnnotation = Annotation.Root({\n  actions: Annotation<any[]>,\n});\n\nexport const CopilotKitStateAnnotation = Annotation.Root({\n  copilotkit: Annotation<typeof CopilotKitPropertiesAnnotation.State>,\n  ...MessagesAnnotation.spec,\n});\n\nexport type CopilotKitState = typeof CopilotKitStateAnnotation.State;\nexport type CopilotKitProperties = typeof CopilotKitPropertiesAnnotation.State;\n\n/**\n * Customize the LangGraph configuration for use in CopilotKit.\n *\n * To the CopilotKit SDK, run:\n *\n * ```bash\n * npm install @copilotkit/sdk-js\n * ```\n *\n * ### Examples\n *\n * Disable emitting messages and tool calls:\n *\n * ```typescript\n * import { copilotkitCustomizeConfig } from \"@copilotkit/sdk-js\";\n *\n * config = copilotkitCustomizeConfig(\n *   config,\n *   emitMessages=false,\n *   emitToolCalls=false\n * )\n * ```\n *\n * To emit a tool call as streaming LangGraph state, pass the destination key in state,\n * the tool name and optionally the tool argument. (If you don't pass the argument name,\n * all arguments are emitted under the state key.)\n *\n * ```typescript\n * import { copilotkitCustomizeConfig } from \"@copilotkit/sdk-js\";\n *\n * config = copilotkitCustomizeConfig(\n *   config,\n *   emitIntermediateState=[\n *     {\n *       \"stateKey\": \"steps\",\n *       \"tool\": \"SearchTool\",\n *       \"toolArgument\": \"steps\",\n *     },\n *   ],\n * )\n * ```\n */\nexport function copilotkitCustomizeConfig(\n  /**\n   * The LangChain/LangGraph configuration to customize.\n   */\n  baseConfig: RunnableConfig,\n  /**\n   * Configuration options:\n   * - `emitMessages: boolean?`\n   *   Configure how messages are emitted. By default, all messages are emitted. Pass false to\n   *   disable emitting messages.\n   * - `emitToolCalls: boolean | string | string[]?`\n   *   Configure how tool calls are emitted. By default, all tool calls are emitted. Pass false to\n   *   disable emitting tool calls. Pass a string or list of strings to emit only specific tool calls.\n   * - `emitIntermediateState: IntermediateStateConfig[]?`\n   *   Lets you emit tool calls as streaming LangGraph state.\n   */\n  options?: OptionsConfig,\n): RunnableConfig {\n  const metadata = baseConfig?.metadata || {};\n\n  if (options?.emitAll) {\n    metadata[\"copilotkit:emit-tool-calls\"] = true;\n    metadata[\"copilotkit:emit-messages\"] = true;\n  } else {\n    if (options?.emitToolCalls !== undefined) {\n      metadata[\"copilotkit:emit-tool-calls\"] = options.emitToolCalls;\n    }\n    if (options?.emitMessages !== undefined) {\n      metadata[\"copilotkit:emit-messages\"] = options.emitMessages;\n    }\n  }\n\n  if (options?.emitIntermediateState) {\n    const snakeCaseIntermediateState = options.emitIntermediateState.map((state) => ({\n      tool: state.tool,\n      tool_argument: state.toolArgument,\n      state_key: state.stateKey,\n    }));\n\n    metadata[\"copilotkit:emit-intermediate-state\"] = snakeCaseIntermediateState;\n  }\n\n  baseConfig = baseConfig || {};\n\n  return {\n    ...baseConfig,\n    metadata: metadata,\n  };\n}\n/**\n * Exits the current agent after the run completes. Calling copilotkit_exit() will\n * not immediately stop the agent. Instead, it signals to CopilotKit to stop the agent after\n * the run completes.\n *\n * ### Examples\n *\n * ```typescript\n * import { copilotkitExit } from \"@copilotkit/sdk-js\";\n *\n * async function myNode(state: Any):\n *   await copilotkitExit(config)\n *   return state\n * ```\n */\nexport async function copilotkitExit(\n  /**\n   * The LangChain/LangGraph configuration.\n   */\n  config: RunnableConfig,\n) {\n  await dispatchCustomEvent(\"copilotkit_exit\", {}, config);\n}\n/**\n * Emits intermediate state to CopilotKit. Useful if you have a longer running node and you want to\n * update the user with the current state of the node.\n *\n * ### Examples\n *\n * ```typescript\n * import { copilotkitEmitState } from \"@copilotkit/sdk-js\";\n *\n * for (let i = 0; i < 10; i++) {\n *   await someLongRunningOperation(i);\n *   await copilotkitEmitState(config, { progress: i });\n * }\n * ```\n */\nexport async function copilotkitEmitState(\n  /**\n   * The LangChain/LangGraph configuration.\n   */\n  config: RunnableConfig,\n  /**\n   * The state to emit.\n   */\n  state: any,\n) {\n  await dispatchCustomEvent(\"copilotkit_manually_emit_intermediate_state\", state, config);\n}\n/**\n * Manually emits a message to CopilotKit. Useful in longer running nodes to update the user.\n * Important: You still need to return the messages from the node.\n *\n * ### Examples\n *\n * ```typescript\n * import { copilotkitEmitMessage } from \"@copilotkit/sdk-js\";\n *\n * const message = \"Step 1 of 10 complete\";\n * await copilotkitEmitMessage(config, message);\n *\n * // Return the message from the node\n * return {\n *   \"messages\": [AIMessage(content=message)]\n * }\n * ```\n */\nexport async function copilotkitEmitMessage(\n  /**\n   * The LangChain/LangGraph configuration.\n   */\n  config: RunnableConfig,\n  /**\n   * The message to emit.\n   */\n  message: string,\n) {\n  await dispatchCustomEvent(\n    \"copilotkit_manually_emit_message\",\n    { message, message_id: randomId(), role: \"assistant\" },\n    config,\n  );\n}\n/**\n * Manually emits a tool call to CopilotKit.\n *\n * ### Examples\n *\n * ```typescript\n * import { copilotkitEmitToolCall } from \"@copilotkit/sdk-js\";\n *\n * await copilotkitEmitToolCall(config, name=\"SearchTool\", args={\"steps\": 10})\n * ```\n */\nexport async function copilotkitEmitToolCall(\n  /**\n   * The LangChain/LangGraph configuration.\n   */\n  config: RunnableConfig,\n  /**\n   * The name of the tool to emit.\n   */\n  name: string,\n  /**\n   * The arguments to emit.\n   */\n  args: any,\n) {\n  await dispatchCustomEvent(\n    \"copilotkit_manually_emit_tool_call\",\n    { name, args, id: randomId() },\n    config,\n  );\n}\n\nexport function convertActionToDynamicStructuredTool(actionInput: any) {\n  return new DynamicStructuredTool({\n    name: actionInput.name,\n    description: actionInput.description,\n    schema: convertJsonSchemaToZodSchema(actionInput.parameters, true),\n    func: async () => {\n      return \"\";\n    },\n  });\n}\n/**\n * Use this function to convert a list of actions you get from state\n * to a list of dynamic structured tools.\n *\n * ### Examples\n *\n * ```typescript\n * import { convertActionsToDynamicStructuredTools } from \"@copilotkit/sdk-js\";\n *\n * const tools = convertActionsToDynamicStructuredTools(state.copilotkit.actions);\n * ```\n */\nexport function convertActionsToDynamicStructuredTools(\n  /**\n   * The list of actions to convert.\n   */\n  actions: any[],\n) {\n  return actions.map((action) => convertActionToDynamicStructuredTool(action));\n}\n\nexport function copilotKitInterrupt({\n  message,\n  action,\n  args,\n}: {\n  message?: string;\n  action?: string;\n  args?: Record<string, any>;\n}) {\n  if (!message && !action) {\n    throw new Error(\"Either message or action (and optional arguments) must be provided\");\n  }\n\n  let interruptValues = null;\n  let interruptMessage = null;\n  let answer = null;\n  if (message) {\n    interruptValues = message;\n    interruptMessage = new AIMessage({ content: message, id: randomId() });\n  } else {\n    const toolId = randomId();\n    interruptMessage = new AIMessage({\n      content: \"\",\n      tool_calls: [{ id: toolId, name: action, args: args ?? {} }],\n    });\n    interruptValues = {\n      action,\n      args: args ?? {},\n    };\n  }\n\n  const response = interrupt({\n    __copilotkit_interrupt_value__: interruptValues,\n    __copilotkit_messages__: [interruptMessage],\n  });\n  answer = response[response.length - 1].content;\n\n  return {\n    answer,\n    messages: response,\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAAA;;;;;;;;;;;;;;;ACCA,sBAAoC;AACpC,oBAAuD;AACvD,uBAA0D;AAC1D,mBAAsC;AACtC,sBAA0B;AAenB,IAAMC,iCAAiCC,4BAAWC,KAAK;EAC5DC,SAASF;AACX,CAAA;AAEO,IAAMG,4BAA4BH,4BAAWC,KAAK;EACvDG,YAAYJ;EACZ,GAAGK,oCAAmBC;AACxB,CAAA;AA+CO,SAASC,0BAIdC,YAYAC,SAAuB;AAEvB,QAAMC,YAAWF,yCAAYE,aAAY,CAAC;AAE1C,MAAID,mCAASE,SAAS;AACpBD,aAAS,4BAAA,IAAgC;AACzCA,aAAS,0BAAA,IAA8B;EACzC,OAAO;AACL,SAAID,mCAASG,mBAAkBC,QAAW;AACxCH,eAAS,4BAAA,IAAgCD,QAAQG;IACnD;AACA,SAAIH,mCAASK,kBAAiBD,QAAW;AACvCH,eAAS,0BAAA,IAA8BD,QAAQK;IACjD;EACF;AAEA,MAAIL,mCAASM,uBAAuB;AAClC,UAAMC,6BAA6BP,QAAQM,sBAAsBE,IAAI,CAACC,WAAW;MAC/EC,MAAMD,MAAMC;MACZC,eAAeF,MAAMG;MACrBC,WAAWJ,MAAMK;IACnB,EAAA;AAEAb,aAAS,oCAAA,IAAwCM;EACnD;AAEAR,eAAaA,cAAc,CAAC;AAE5B,SAAO;IACL,GAAGA;IACHE;EACF;AACF;AAhDgBH;AAgEhB,eAAsBiB,eAIpBC,QAAsB;AAEtB,YAAMC,qCAAoB,mBAAmB,CAAC,GAAGD,MAAAA;AACnD;AAPsBD;AAuBtB,eAAsBG,oBAIpBF,QAIAP,OAAU;AAEV,YAAMQ,qCAAoB,+CAA+CR,OAAOO,MAAAA;AAClF;AAXsBE;AA8BtB,eAAsBC,sBAIpBH,QAIAI,SAAe;AAEf,YAAMH,qCACJ,oCACA;IAAEG;IAASC,gBAAYC,wBAAAA;IAAYC,MAAM;EAAY,GACrDP,MAAAA;AAEJ;AAfsBG;AA2BtB,eAAsBK,uBAIpBR,QAIAS,MAIAC,MAAS;AAET,YAAMT,qCACJ,sCACA;IAAEQ;IAAMC;IAAMC,QAAIL,wBAAAA;EAAW,GAC7BN,MAAAA;AAEJ;AAnBsBQ;AAqBf,SAASI,qCAAqCC,aAAgB;AACnE,SAAO,IAAIC,mCAAsB;IAC/BL,MAAMI,YAAYJ;IAClBM,aAAaF,YAAYE;IACzBC,YAAQC,4CAA6BJ,YAAYK,YAAY,IAAA;IAC7DC,MAAM,YAAA;AACJ,aAAO;IACT;EACF,CAAA;AACF;AATgBP;AAsBT,SAASQ,uCAId3C,SAAc;AAEd,SAAOA,QAAQe,IAAI,CAAC6B,WAAWT,qCAAqCS,MAAAA,CAAAA;AACtE;AAPgBD;;;ADrQhBE,QAAQC,KACN,mJAAA;","names":["console","CopilotKitPropertiesAnnotation","Annotation","Root","actions","CopilotKitStateAnnotation","copilotkit","MessagesAnnotation","spec","copilotkitCustomizeConfig","baseConfig","options","metadata","emitAll","emitToolCalls","undefined","emitMessages","emitIntermediateState","snakeCaseIntermediateState","map","state","tool","tool_argument","toolArgument","state_key","stateKey","copilotkitExit","config","dispatchCustomEvent","copilotkitEmitState","copilotkitEmitMessage","message","message_id","randomId","role","copilotkitEmitToolCall","name","args","id","convertActionToDynamicStructuredTool","actionInput","DynamicStructuredTool","description","schema","convertJsonSchemaToZodSchema","parameters","func","convertActionsToDynamicStructuredTools","action","console","warn"]}