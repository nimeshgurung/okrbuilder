{"version":3,"sources":["../../src/utils/json-schema.test.ts","../../src/utils/json-schema.ts"],"sourcesContent":["import { z } from \"zod\";\nimport {\n  convertJsonSchemaToZodSchema,\n  actionParametersToJsonSchema,\n  jsonSchemaToActionParameters,\n  JSONSchema,\n} from \"../utils/json-schema\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { Parameter } from \"../types\";\n\ndescribe(\"convertJsonSchemaToZodSchema\", () => {\n  it(\"should convert a simple JSON schema to a Zod schema\", () => {\n    const jsonSchema = {\n      type: \"object\",\n      properties: {\n        name: { type: \"string\" },\n        age: { type: \"number\" },\n      },\n      required: [\"name\", \"age\"],\n    };\n\n    const expectedSchema = z.object({\n      name: z.string(),\n      age: z.number(),\n    });\n\n    const result = convertJsonSchemaToZodSchema(jsonSchema, true);\n    const resultSchemaJson = zodToJsonSchema(result);\n    const expectedSchemaJson = zodToJsonSchema(expectedSchema);\n\n    expect(resultSchemaJson).toStrictEqual(expectedSchemaJson);\n  });\n\n  it(\"should convert a JSON schema with nested objects to a Zod schema\", () => {\n    const jsonSchema = {\n      type: \"object\",\n      properties: {\n        name: { type: \"string\" },\n        address: {\n          type: \"object\",\n          properties: {\n            street: { type: \"string\" },\n            city: { type: \"string\" },\n          },\n          required: [\"street\", \"city\"],\n        },\n      },\n      required: [\"name\", \"address\"],\n    };\n\n    const expectedSchema = z.object({\n      name: z.string(),\n      address: z.object({\n        street: z.string(),\n        city: z.string(),\n      }),\n    });\n\n    const result = convertJsonSchemaToZodSchema(jsonSchema, true);\n    const resultSchemaJson = zodToJsonSchema(result);\n    const expectedSchemaJson = zodToJsonSchema(expectedSchema);\n\n    expect(resultSchemaJson).toStrictEqual(expectedSchemaJson);\n  });\n\n  it(\"should convert a JSON schema with arrays to a Zod schema\", () => {\n    const jsonSchema = {\n      type: \"object\",\n      properties: {\n        names: {\n          type: \"array\",\n          items: { type: \"string\" },\n        },\n      },\n      required: [\"names\"],\n    };\n\n    const expectedSchema = z.object({\n      names: z.array(z.string()),\n    });\n\n    const result = convertJsonSchemaToZodSchema(jsonSchema, true);\n    const resultSchemaJson = zodToJsonSchema(result);\n    const expectedSchemaJson = zodToJsonSchema(expectedSchema);\n\n    expect(resultSchemaJson).toStrictEqual(expectedSchemaJson);\n  });\n\n  it(\"should convert a JSON schema with optional properties to a Zod schema\", () => {\n    const jsonSchema = {\n      type: \"object\",\n      properties: {\n        name: { type: \"string\" },\n        age: { type: \"number\", required: false },\n      },\n    };\n\n    const expectedSchema = z\n      .object({\n        name: z.string().optional(),\n        age: z.number().optional(),\n      })\n      .optional();\n\n    const result = convertJsonSchemaToZodSchema(jsonSchema, false);\n\n    console.log(convertJsonSchemaToZodSchema(jsonSchema, false));\n\n    const resultSchemaJson = zodToJsonSchema(result);\n    const expectedSchemaJson = zodToJsonSchema(expectedSchema);\n\n    expect(resultSchemaJson).toStrictEqual(expectedSchemaJson);\n  });\n\n  it(\"should convert a JSON schema with different types to a Zod schema\", () => {\n    const jsonSchema = {\n      type: \"object\",\n      properties: {\n        name: { type: \"string\" },\n        age: { type: \"number\" },\n        isAdmin: { type: \"boolean\" },\n      },\n      required: [\"name\", \"age\", \"isAdmin\"],\n    };\n\n    const expectedSchema = z.object({\n      name: z.string(),\n      age: z.number(),\n      isAdmin: z.boolean(),\n    });\n\n    const result = convertJsonSchemaToZodSchema(jsonSchema, true);\n    const resultSchemaJson = zodToJsonSchema(result);\n    const expectedSchemaJson = zodToJsonSchema(expectedSchema);\n\n    expect(resultSchemaJson).toStrictEqual(expectedSchemaJson);\n  });\n\n  it(\"should handle edge case where JSON schema has no properties\", () => {\n    const jsonSchema = {\n      type: \"object\",\n    };\n\n    const expectedSchema = z.object({});\n\n    const result = convertJsonSchemaToZodSchema(jsonSchema, true);\n    const resultSchemaJson = zodToJsonSchema(result);\n    const expectedSchemaJson = zodToJsonSchema(expectedSchema);\n\n    expect(resultSchemaJson).toStrictEqual(expectedSchemaJson);\n  });\n\n  it(\"should handle edge case where JSON schema has no required properties\", () => {\n    const jsonSchema = {\n      type: \"object\",\n      properties: {\n        name: { type: \"string\" },\n        age: { type: \"number\" },\n      },\n    };\n\n    const expectedSchema = z\n      .object({\n        name: z.string().optional(),\n        age: z.number().optional(),\n      })\n      .optional();\n\n    const result = convertJsonSchemaToZodSchema(jsonSchema, false);\n    const resultSchemaJson = zodToJsonSchema(result);\n    const expectedSchemaJson = zodToJsonSchema(expectedSchema);\n\n    expect(resultSchemaJson).toStrictEqual(expectedSchemaJson);\n  });\n});\n\ndescribe(\"jsonSchemaToActionParameters\", () => {\n  it(\"should convert a simple JSONSchema to Parameter array\", () => {\n    const jsonSchema: JSONSchema = {\n      type: \"object\",\n      properties: {\n        name: { type: \"string\", description: \"User name\" },\n        age: { type: \"number\", description: \"User age\" },\n      },\n      required: [\"name\"],\n    };\n\n    const expectedParameters: Parameter[] = [\n      { name: \"name\", type: \"string\", description: \"User name\" },\n      { name: \"age\", type: \"number\", description: \"User age\", required: false },\n    ];\n\n    const result = jsonSchemaToActionParameters(jsonSchema);\n    expect(result).toEqual(expectedParameters);\n  });\n\n  it(\"should convert JSONSchema with enum to Parameter array\", () => {\n    const jsonSchema: JSONSchema = {\n      type: \"object\",\n      properties: {\n        role: { type: \"string\", enum: [\"admin\", \"user\", \"guest\"], description: \"User role\" },\n      },\n      required: [\"role\"],\n    };\n\n    const expectedParameters: Parameter[] = [\n      { name: \"role\", type: \"string\", enum: [\"admin\", \"user\", \"guest\"], description: \"User role\" },\n    ];\n\n    const result = jsonSchemaToActionParameters(jsonSchema);\n    expect(result).toEqual(expectedParameters);\n  });\n\n  it(\"should convert nested object JSONSchema to Parameter array\", () => {\n    const jsonSchema: JSONSchema = {\n      type: \"object\",\n      properties: {\n        user: {\n          type: \"object\",\n          properties: {\n            name: { type: \"string\", description: \"User name\" },\n            age: { type: \"number\", description: \"User age\" },\n          },\n          required: [\"name\"],\n          description: \"User information\",\n        },\n      },\n      required: [\"user\"],\n    };\n\n    const expectedParameters: Parameter[] = [\n      {\n        name: \"user\",\n        type: \"object\",\n        description: \"User information\",\n        attributes: [\n          { name: \"name\", type: \"string\", description: \"User name\" },\n          { name: \"age\", type: \"number\", description: \"User age\", required: false },\n        ],\n      },\n    ];\n\n    const result = jsonSchemaToActionParameters(jsonSchema);\n    expect(result).toEqual(expectedParameters);\n  });\n\n  it(\"should convert array JSONSchema to Parameter array\", () => {\n    const jsonSchema: JSONSchema = {\n      type: \"object\",\n      properties: {\n        tags: {\n          type: \"array\",\n          items: { type: \"string\" },\n          description: \"User tags\",\n        },\n      },\n      required: [\"tags\"],\n    };\n\n    const expectedParameters: Parameter[] = [\n      { name: \"tags\", type: \"string[]\", description: \"User tags\" },\n    ];\n\n    const result = jsonSchemaToActionParameters(jsonSchema);\n    expect(result).toEqual(expectedParameters);\n  });\n\n  it(\"should convert object array JSONSchema to Parameter array\", () => {\n    const jsonSchema: JSONSchema = {\n      type: \"object\",\n      properties: {\n        addresses: {\n          type: \"array\",\n          items: {\n            type: \"object\",\n            properties: {\n              street: { type: \"string\", description: \"Street name\" },\n              city: { type: \"string\", description: \"City name\" },\n            },\n            required: [\"street\"],\n          },\n          description: \"User addresses\",\n        },\n      },\n      required: [\"addresses\"],\n    };\n\n    const expectedParameters: Parameter[] = [\n      {\n        name: \"addresses\",\n        type: \"object[]\",\n        description: \"User addresses\",\n        attributes: [\n          { name: \"street\", type: \"string\", description: \"Street name\" },\n          { name: \"city\", type: \"string\", description: \"City name\", required: false },\n        ],\n      },\n    ];\n\n    const result = jsonSchemaToActionParameters(jsonSchema);\n    expect(result).toEqual(expectedParameters);\n  });\n\n  it(\"should handle boolean types\", () => {\n    const jsonSchema: JSONSchema = {\n      type: \"object\",\n      properties: {\n        isAdmin: { type: \"boolean\", description: \"Is user an admin\" },\n      },\n      required: [\"isAdmin\"],\n    };\n\n    const expectedParameters: Parameter[] = [\n      { name: \"isAdmin\", type: \"boolean\", description: \"Is user an admin\" },\n    ];\n\n    const result = jsonSchemaToActionParameters(jsonSchema);\n    expect(result).toEqual(expectedParameters);\n  });\n\n  it(\"should handle empty object schema\", () => {\n    const jsonSchema: JSONSchema = {\n      type: \"object\",\n    };\n\n    const expectedParameters: Parameter[] = [];\n\n    const result = jsonSchemaToActionParameters(jsonSchema);\n    expect(result).toEqual(expectedParameters);\n  });\n\n  it(\"should throw error for nested arrays\", () => {\n    const jsonSchema: JSONSchema = {\n      type: \"object\",\n      properties: {\n        nestedArray: {\n          type: \"array\",\n          items: {\n            type: \"array\",\n            items: { type: \"string\" },\n          },\n          description: \"Matrix of strings\",\n        },\n      },\n      required: [\"nestedArray\"],\n    };\n\n    expect(() => jsonSchemaToActionParameters(jsonSchema)).toThrow(\n      \"Nested arrays are not supported\",\n    );\n  });\n\n  it(\"should ensure round-trip conversion works\", () => {\n    const originalParameters: Parameter[] = [\n      { name: \"name\", type: \"string\", description: \"User name\" },\n      { name: \"age\", type: \"number\", description: \"User age\", required: false },\n      { name: \"role\", type: \"string\", enum: [\"admin\", \"user\"], description: \"User role\" },\n      {\n        name: \"address\",\n        type: \"object\",\n        description: \"User address\",\n        attributes: [\n          { name: \"street\", type: \"string\", description: \"Street name\" },\n          { name: \"city\", type: \"string\", description: \"City name\" },\n        ],\n      },\n      {\n        name: \"contacts\",\n        type: \"object[]\",\n        description: \"User contacts\",\n        attributes: [\n          { name: \"type\", type: \"string\", description: \"Contact type\" },\n          { name: \"value\", type: \"string\", description: \"Contact value\" },\n        ],\n      },\n    ];\n\n    const jsonSchema = actionParametersToJsonSchema(originalParameters);\n    const roundTripParameters = jsonSchemaToActionParameters(jsonSchema);\n\n    expect(roundTripParameters).toEqual(originalParameters);\n  });\n});\n","import { z } from \"zod\";\nimport { Parameter } from \"../types\";\n\nexport type JSONSchemaString = {\n  type: \"string\";\n  description?: string;\n  enum?: string[];\n};\n\nexport type JSONSchemaNumber = {\n  type: \"number\";\n  description?: string;\n};\n\nexport type JSONSchemaBoolean = {\n  type: \"boolean\";\n  description?: string;\n};\n\nexport type JSONSchemaObject = {\n  type: \"object\";\n  properties?: Record<string, JSONSchema>;\n  required?: string[];\n  description?: string;\n};\n\nexport type JSONSchemaArray = {\n  type: \"array\";\n  items: JSONSchema;\n  description?: string;\n};\n\nexport type JSONSchema =\n  | JSONSchemaString\n  | JSONSchemaNumber\n  | JSONSchemaBoolean\n  | JSONSchemaObject\n  | JSONSchemaArray;\n\nexport function actionParametersToJsonSchema(actionParameters: Parameter[]): JSONSchema {\n  // Create the parameters object based on the argumentAnnotations\n  let parameters: { [key: string]: any } = {};\n  for (let parameter of actionParameters || []) {\n    parameters[parameter.name] = convertAttribute(parameter);\n  }\n\n  let requiredParameterNames: string[] = [];\n  for (let arg of actionParameters || []) {\n    if (arg.required !== false) {\n      requiredParameterNames.push(arg.name);\n    }\n  }\n\n  // Create the ChatCompletionFunctions object\n  return {\n    type: \"object\",\n    properties: parameters,\n    required: requiredParameterNames,\n  };\n}\n\n// Convert JSONSchema to Parameter[]\nexport function jsonSchemaToActionParameters(jsonSchema: JSONSchema): Parameter[] {\n  if (jsonSchema.type !== \"object\" || !jsonSchema.properties) {\n    return [];\n  }\n\n  const parameters: Parameter[] = [];\n  const requiredFields = jsonSchema.required || [];\n\n  for (const [name, schema] of Object.entries(jsonSchema.properties)) {\n    const parameter = convertJsonSchemaToParameter(name, schema, requiredFields.includes(name));\n    parameters.push(parameter);\n  }\n\n  return parameters;\n}\n\n// Convert JSONSchema property to Parameter\nfunction convertJsonSchemaToParameter(\n  name: string,\n  schema: JSONSchema,\n  isRequired: boolean,\n): Parameter {\n  const baseParameter: Parameter = {\n    name,\n    description: schema.description,\n  };\n\n  if (!isRequired) {\n    baseParameter.required = false;\n  }\n\n  switch (schema.type) {\n    case \"string\":\n      return {\n        ...baseParameter,\n        type: \"string\",\n        ...(schema.enum && { enum: schema.enum }),\n      };\n    case \"number\":\n    case \"boolean\":\n      return {\n        ...baseParameter,\n        type: schema.type,\n      };\n    case \"object\":\n      if (schema.properties) {\n        const attributes: Parameter[] = [];\n        const requiredFields = schema.required || [];\n\n        for (const [propName, propSchema] of Object.entries(schema.properties)) {\n          attributes.push(\n            convertJsonSchemaToParameter(propName, propSchema, requiredFields.includes(propName)),\n          );\n        }\n\n        return {\n          ...baseParameter,\n          type: \"object\",\n          attributes,\n        };\n      }\n      return {\n        ...baseParameter,\n        type: \"object\",\n      };\n    case \"array\":\n      if (schema.items.type === \"object\" && \"properties\" in schema.items) {\n        const attributes: Parameter[] = [];\n        const requiredFields = schema.items.required || [];\n\n        for (const [propName, propSchema] of Object.entries(schema.items.properties || {})) {\n          attributes.push(\n            convertJsonSchemaToParameter(propName, propSchema, requiredFields.includes(propName)),\n          );\n        }\n\n        return {\n          ...baseParameter,\n          type: \"object[]\",\n          attributes,\n        };\n      } else if (schema.items.type === \"array\") {\n        throw new Error(\"Nested arrays are not supported\");\n      } else {\n        return {\n          ...baseParameter,\n          type: `${schema.items.type}[]`,\n        };\n      }\n    default:\n      return {\n        ...baseParameter,\n        type: \"string\",\n      };\n  }\n}\n\nfunction convertAttribute(attribute: Parameter): JSONSchema {\n  switch (attribute.type) {\n    case \"string\":\n      return {\n        type: \"string\",\n        description: attribute.description,\n        ...(attribute.enum && { enum: attribute.enum }),\n      };\n    case \"number\":\n    case \"boolean\":\n      return {\n        type: attribute.type,\n        description: attribute.description,\n      };\n    case \"object\":\n    case \"object[]\":\n      const properties = attribute.attributes?.reduce(\n        (acc, attr) => {\n          acc[attr.name] = convertAttribute(attr);\n          return acc;\n        },\n        {} as Record<string, any>,\n      );\n      const required = attribute.attributes\n        ?.filter((attr) => attr.required !== false)\n        .map((attr) => attr.name);\n      if (attribute.type === \"object[]\") {\n        return {\n          type: \"array\",\n          items: {\n            type: \"object\",\n            ...(properties && { properties }),\n            ...(required && required.length > 0 && { required }),\n          },\n          description: attribute.description,\n        };\n      }\n      return {\n        type: \"object\",\n        description: attribute.description,\n        ...(properties && { properties }),\n        ...(required && required.length > 0 && { required }),\n      };\n    default:\n      // Handle arrays of primitive types and undefined attribute.type\n      if (attribute.type?.endsWith(\"[]\")) {\n        const itemType = attribute.type.slice(0, -2);\n        return {\n          type: \"array\",\n          items: { type: itemType as any },\n          description: attribute.description,\n        };\n      }\n      // Fallback for undefined type or any other unexpected type\n      return {\n        type: \"string\",\n        description: attribute.description,\n      };\n  }\n}\n\nexport function convertJsonSchemaToZodSchema(jsonSchema: any, required: boolean): z.ZodSchema {\n  if (jsonSchema.type === \"object\") {\n    const spec: { [key: string]: z.ZodSchema } = {};\n\n    if (!jsonSchema.properties || !Object.keys(jsonSchema.properties).length) {\n      return !required ? z.object(spec).optional() : z.object(spec);\n    }\n\n    for (const [key, value] of Object.entries(jsonSchema.properties)) {\n      spec[key] = convertJsonSchemaToZodSchema(\n        value,\n        jsonSchema.required ? jsonSchema.required.includes(key) : false,\n      );\n    }\n    let schema = z.object(spec).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"string\") {\n    let schema = z.string().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"number\") {\n    let schema = z.number().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"boolean\") {\n    let schema = z.boolean().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"array\") {\n    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, true);\n    let schema = z.array(itemSchema).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  }\n  throw new Error(\"Invalid JSON schema\");\n}\n"],"mappings":"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","names":["import_zod"]}